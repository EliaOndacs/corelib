from contextlib import contextmanager
from functools import partial
from typing import Callable, Protocol, Generator, Iterable
import sys, time


class Symbol[OptionalTyping]:
    "the Symbol class allows you to construct symbol type which is unique every time."
    data: OptionalTyping | None = None

    def __str__(self):
        return str(self.data) if self.data else "[ object of type symbol ]"


def bind(data: object):
    "bind a object to function"

    def decorator(func):
        return partial(func, data)

    return decorator


class Driver(Protocol):
    def setup(self): ...
    def call(self, func: Callable, *args, **kwargs): ...
    def clear(self): ...
    def data(self, obj: object): ...
    def __call__(self, call: object, *args, **kwds): ...


class TerminalDriver(Driver):
    def setup(self):
        print("started the terminal driver | version: 1.0.0", file=sys.stderr)
        self.ansi_stack: list[str] = []

    def pushAnsi(self, code: str):
        self.ansi_stack.append(code)
        self.data(code)

    def popAnsi(self):
        if len(self.ansi_stack) <= 1:
            self.data("\x1b[0m")
            return ""
        code = self.ansi_stack.pop()
        self.data(self.ansi_stack[-1])
        return code

    def call(self, func: Callable, *args, **kwargs):
        return func(*args, **kwargs)

    def clear(self):
        print("\x1b[H\x1b[2J\r", end="", flush=True)
        return

    def data(self, obj: object):
        print(obj, end="", flush=True)
        return

    def _break(self):
        print("\n", end="", flush=True)
        return

    def __call__(self, call: object, *args, **kwargs):
        if callable(call):
            self.call(call, *args, **kwargs)
        elif call == "clear":
            self.clear()
        elif call == "break":
            self._break()
        elif isinstance(call, str):
            self.data(call)
        else:
            raise RuntimeError(f"unsupported driver call: {call!r}")


def sequencer[
    T
](pattern: str, function: Callable[[str], T], *, wait: float | int = 0) -> Generator[
    T, None, None
]:
    for char in pattern:
        yield function(char)
        if wait != 0:
            time.sleep(wait)


@contextmanager
def trycatch(on_error: Callable[[Exception], None]):
    try:
        yield
    except Exception as err:
        on_error(err)

def merge_sequence[T](sequence1: Iterable[T], sequence2: Iterable[T]) -> list[T]:
    result: list[T] = []
    i, j = 0, 0
    seq1 = list(sequence1)
    seq2 = list(sequence2)
    while i < len(seq1) and j < len(seq2):
        if seq1[i] < seq2[j]:  # type: ignore
            result.append(seq1[i])
            i += 1
        else:
            result.append(seq2[j])
            j += 1
    while i < len(seq1):
        result.append(seq1[i])
        i += 1
    while j < len(seq2):
        result.append(seq2[j])
        j += 1
    return result

_initiated: list[str] = []
"list of already initiated id's"


def initiate(id: str):
    """
    helpful function for a check to only be ran once
    for example:
    ```python
    while 1:
        if initiate("once"):
            print("this only runs once")
    ```
    in this example the print function only runs once
    """

    global _initiated
    if id in _initiated:
        return False
    _initiated.append(id)
    return True

_keys: dict[str, list[str]] = {}
"stores all the keys generated by keygen in their own namespace"


def create_keygen(name: str):
    "creates a new keygen namespace"
    global _keys
    _keys[name] = []
    return name


def does_key_namespace_exist(name: str):
    "return True if the keygen namespace exists"
    if not (name in _keys):
        raise KeyError(f"keygen namespace {name!r} not found!")


def keygen(name: str) -> str:
    "generate a new key for the specefied namespace"
    global _keys
    does_key_namespace_exist(name)
    _ns = _keys[name]
    key = f"{len(_ns)}.key"
    _keys[name].append(key)
    return key


def does_key_exists(key: str, name: str):
    "return True if key exist"
    does_key_namespace_exist(name)
    _ns = _keys[name]
    return key in _ns


